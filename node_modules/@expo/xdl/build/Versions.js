"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.versionsAsync = versionsAsync;
exports.sdkVersionsAsync = sdkVersionsAsync;
exports.turtleSdkVersionsAsync = turtleSdkVersionsAsync;
exports.setVersionsAsync = setVersionsAsync;
exports.gteSdkVersion = gteSdkVersion;
exports.lteSdkVersion = lteSdkVersion;
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
exports.newestSdkVersionAsync = newestSdkVersionAsync;
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
exports.facebookReactNativeVersionsAsync = facebookReactNativeVersionsAsync;
exports.facebookReactNativeVersionToExpoVersionAsync = facebookReactNativeVersionToExpoVersionAsync;
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _ApiV = _interopRequireDefault(require("./ApiV2"));

var _FsCache = require("./tools/FsCache");

var _XDLError = _interopRequireDefault(require("./XDLError"));

var _User = _interopRequireDefault(require("./User"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function versionsAsync() {
  const api = new _ApiV.default();
  const versionCache = new _FsCache.Cacher(() => api.getAsync('versions/latest'), 'versions.json', 0, _path.default.join(__dirname, '../caches/versions.json'));
  return await versionCache.getAsync();
}

async function sdkVersionsAsync() {
  const {
    sdkVersions
  } = await versionsAsync();
  return sdkVersions;
}

async function turtleSdkVersionsAsync() {
  const {
    turtleSdkVersions
  } = await versionsAsync();
  return turtleSdkVersions;
}

async function setVersionsAsync(value) {
  const user = await _User.default.getCurrentUserAsync();

  const api = _ApiV.default.clientForUser(user);

  return await api.postAsync('versions/update', {
    value,
    secret: process.env.EXPO_VERSIONS_SECRET
  });
}

function gteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return true;
  }

  try {
    return _semver.default.gte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new _XDLError.default('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function lteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return false;
  }

  try {
    return _semver.default.lte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new _XDLError.default('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function parseSdkVersionFromTag(tag) {
  if (tag.startsWith('sdk-')) {
    return tag.substring(4);
  }

  return tag;
}

async function newestSdkVersionAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let result = {};
  let highestMajorVersion = '0.0.0';

  _lodash.default.forEach(sdkVersions, (value, key) => {
    if (_semver.default.major(key) > _semver.default.major(highestMajorVersion)) {
      highestMajorVersion = key;
      result = value;
    }
  });

  result.version = highestMajorVersion;
  return result;
}

async function oldestSupportedMajorVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();

  const supportedVersions = _lodash.default.pickBy(sdkVersions, v => !v.isDeprecated);

  let versionNumbers = [];

  _lodash.default.forEach(supportedVersions, (value, key) => {
    versionNumbers.push(_semver.default.major(key));
  });

  return Math.min(...versionNumbers);
}

async function facebookReactNativeVersionsAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let facebookReactNativeVersions = new Set();

  _lodash.default.forEach(sdkVersions, value => {
    if (value.facebookReactNativeVersion) {
      facebookReactNativeVersions.add(value.facebookReactNativeVersion);
    }
  });

  return Array.from(facebookReactNativeVersions);
}

async function facebookReactNativeVersionToExpoVersionAsync(facebookReactNativeVersion) {
  if (!_semver.default.valid(facebookReactNativeVersion)) {
    throw new _XDLError.default('INVALID_VERSION', `${facebookReactNativeVersion} is not a valid version. Must be in the form of x.y.z`);
  }

  let sdkVersions = await sdkVersionsAsync();
  let currentSdkVersion = null;

  _lodash.default.forEach(sdkVersions, (value, key) => {
    if (_semver.default.major(value.facebookReactNativeVersion) === _semver.default.major(facebookReactNativeVersion) && _semver.default.minor(value.facebookReactNativeVersion) === _semver.default.minor(facebookReactNativeVersion) && (!currentSdkVersion || _semver.default.gt(key, currentSdkVersion))) {
      currentSdkVersion = key;
    }
  });

  return currentSdkVersion;
}

async function canTurtleBuildSdkVersion(sdkVersion, platform) {
  if (sdkVersion === 'UNVERSIONED') {
    return true;
  }

  if (_semver.default.valid(sdkVersion) == null) {
    throw new _XDLError.default('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
  }

  const turtleSdkVersions = await turtleSdkVersionsAsync();
  const expoSdkVersion = (await sdkVersionsAsync())[sdkVersion];

  if (expoSdkVersion === undefined) {
    throw new _XDLError.default('INVALID_VERSION', `"${sdkVersion}" is not a valid Expo SDK version.`);
  } else if (expoSdkVersion.isDeprecated) {
    throw new _XDLError.default('INVALID_VERSION', `"${sdkVersion}" is deprecated. Please update Expo SDK version.`);
  }

  if (!turtleSdkVersions || !turtleSdkVersions[platform]) {
    return true;
  }

  const turtleSdkVersion = turtleSdkVersions[platform];
  return _semver.default.gte(turtleSdkVersion, sdkVersion);
}
//# sourceMappingURL=__sourcemaps__/Versions.js.map
