"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBinariesPath = getBinariesPath;
exports.addToPathAsync = addToPathAsync;
exports.sourceBashLoginScriptsAsync = sourceBashLoginScriptsAsync;
exports.writePathToUserSettingsAsync = writePathToUserSettingsAsync;
exports.isXcodeInstalled = isXcodeInstalled;
exports.OSX_SOURCE_PATH = void 0;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _hasbin = _interopRequireDefault(require("hasbin"));

var _spawnAsync = _interopRequireDefault(require("@expo/spawn-async"));

var _path = _interopRequireDefault(require("path"));

var _Config = _interopRequireDefault(require("./Config"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _UserSettings = _interopRequireDefault(require("./UserSettings"));

var _XDLError = _interopRequireDefault(require("./XDLError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let hasSourcedBashLoginScripts = false;

const OSX_SOURCE_PATH = _path.default.join(__dirname, '..', 'binaries', 'osx');

exports.OSX_SOURCE_PATH = OSX_SOURCE_PATH;
const ERROR_MESSAGE = '\nPlease run `npm install -g exp && exp path`';

function _hasbinAsync(name) {
  return new Promise((resolve, reject) => {
    (0, _hasbin.default)(name, result => {
      resolve(result);
    });
  });
}

function getBinariesPath() {
  if (process.platform === 'darwin') {
    return _path.default.join(__dirname, '..', 'binaries', 'osx');
  } else if (process.platform === 'win32') {
    return _path.default.join(__dirname, '..', 'binaries', 'windows');
  } else if (process.platform === 'linux') {
    return _path.default.join(__dirname, '..', 'binaries', 'linux');
  } else {
    throw new _XDLError.default('PLATFORM_NOT_SUPPORTED', 'Platform not supported.');
  }
}

async function addToPathAsync(name) {
  await sourceBashLoginScriptsAsync();

  if (await _hasbinAsync(name)) {
    return;
  } // Users can set {ignoreBundledBinaries: ["watchman"]} to tell us to never use our version


  let ignoreBundledBinaries = await _UserSettings.default.getAsync('ignoreBundledBinaries', []);

  if (ignoreBundledBinaries.includes(name)) {
    return;
  }

  let binariesPath = _path.default.join(getBinariesPath(), name);

  _prependToPath(binariesPath);
}

function _expoRCFileExists() {
  try {
    return _fsExtra.default.statSync(_path.default.join(_UserSettings.default.dotExpoHomeDirectory(), 'bashrc')).isFile();
  } catch (e) {
    return false;
  }
}

function _prependToPath(newPath) {
  let currentPath = process.env.PATH ? process.env.PATH : '';

  if (currentPath.length > 0) {
    let delimiter = process.platform === 'win32' ? ';' : ':';
    currentPath = `${delimiter}${currentPath}`;
  }

  process.env.PATH = `${newPath}${currentPath}`;
}

async function sourceBashLoginScriptsAsync() {
  if (hasSourcedBashLoginScripts || process.platform === 'win32') {
    return;
  }

  if (_Config.default.developerTool !== 'xde') {
    return;
  }

  hasSourcedBashLoginScripts = true;
  let userSettingsPATH = await _UserSettings.default.getAsync('PATH', null);

  if (userSettingsPATH) {
    _prependToPath(userSettingsPATH);
  } else if (_expoRCFileExists()) {
    try {
      // User has a ~/.expo/bashrc. Run that and grab PATH.
      let result = await (0, _spawnAsync.default)(_path.default.join(getBinariesPath(), `get-path-bash`), {
        env: {
          PATH: ''
        }
      });

      if (result.stderr) {
        _Logger.default.global.warn(`Error sourcing ~/.expo/bashrc script: ${result.stderr}`);
      }

      if (result.stdout) {
        _prependToPath(result.stdout);
      }
    } catch (e) {
      _Logger.default.global.warn(`Error sourcing ~/.expo/bashrc script: ${e.stderr}`);
    }
  } else {
    try {
      // No ~/.expo/bashrc file found. Run `env` in process.env.SHELL.
      const shellName = process.env.SHELL;

      if (!shellName) {
        throw new Error('This command requires being run within a shell.');
      }

      let result;

      if (/t?csh$/.test(shellName)) {
        // csh
        result = await (0, _spawnAsync.default)(shellName, ['-d', '-c', 'env']);
      } else if (/zsh$/.test(shellName)) {
        // zsh
        result = await (0, _spawnAsync.default)(shellName, ['-l', '-c', 'env']);
      } else {
        // bash, fish
        result = await (0, _spawnAsync.default)(shellName, ['-l', '-c', 'env']);
      }

      if (result.stderr) {
        _Logger.default.global.warn(`Error sourcing shell startup scripts: ${result.stderr}.${ERROR_MESSAGE}`);
      }

      if (result.stdout) {
        let regexResult = result.stdout.match(/(^|\n)PATH=(.+)/);

        if (regexResult.length >= 3) {
          _prependToPath(regexResult[2]);
        } else {
          _Logger.default.global.warn(`Error parsing shell startup scripts output: ${result.stderr}.${ERROR_MESSAGE}`);
        }
      }
    } catch (e) {
      _Logger.default.global.warn(`Error sourcing shell startup scripts: ${e.stderr}.${ERROR_MESSAGE}`);
    }
  }
}

async function writePathToUserSettingsAsync() {
  await _UserSettings.default.setAsync('PATH', process.env.PATH); // Used in detach app

  let pathFile = _path.default.join(_UserSettings.default.dotExpoHomeDirectory(), 'PATH');

  await _fsExtra.default.writeFile(pathFile, process.env.PATH);
}

function _isDirectory(dir) {
  try {
    if (_fsExtra.default.statSync(dir).isDirectory()) {
      return true;
    }

    return false;
  } catch (e) {
    return false;
  }
}

function isXcodeInstalled() {
  return _isDirectory('/Applications/Xcode.app/');
}
//# sourceMappingURL=__sourcemaps__/Binaries.js.map
