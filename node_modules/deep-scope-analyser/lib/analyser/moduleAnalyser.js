"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scopeManager_1 = require("../scopeManager");
const assert = require("assert");
const referencer_1 = require("../referencer");
const reference_1 = require("../reference");
const childScopesTraverser_1 = require("./childScopesTraverser");
const exportManager_1 = require("../exportManager");
const virtualScope_1 = require("./virtualScope");
const importManager_1 = require("../importManager");
const utils_1 = require("../utils");
Object.defineProperty(Array.prototype, "flatMap", {
    value(f) {
        return this.reduce((ys, x) => {
            return ys.concat(f.call(this, x));
        }, []);
    },
    enumerable: false,
});
class ModuleAnalyser {
    constructor(name, module, scopeManager = null) {
        this.name = name;
        this.module = module;
        this.scopeManager = scopeManager;
        this.extractorMap = new Map();
        this.virtualScopeMap = new WeakMap();
        this.virtualScopes = [];
        this.initVirtualScopes = [];
        this.comments = [];
        this.handleNotExportReferences = (refs) => {
            const moduleScopeRefs = refs.filter(ref => ref.resolved && ref.resolved.scope.type === "module");
            const pureVScopes = this.virtualScopes.filter(vs => vs.contentType === virtualScope_1.VScopeContentType.PureFunctionCall);
            const nodeContains = (node, [start, end]) => {
                return node.start >= start && node.end <= end;
            };
            moduleScopeRefs.forEach(ref => {
                for (const vs of pureVScopes) {
                    if (vs instanceof virtualScope_1.VariableVirtualScope) {
                        const range = vs.pureRange;
                        if (nodeContains(ref.identifier, range)) {
                            return;
                        }
                    }
                }
                const resolvedName = ref.resolved;
                const vs = this.virtualScopeMap.get(resolvedName);
                if (!ref.init) {
                    this.initVirtualScopes.push(vs);
                }
            });
        };
    }
    defaultOptions() {
        return {
            optimistic: false,
            directive: false,
            nodejsScope: false,
            impliedStrict: false,
            sourceType: "module",
            ecmaVersion: 6,
            childVisitorKeys: null,
            fallback: "iteration",
            comments: [],
        };
    }
    get rootId() {
        return this.moduleScope.variables.length;
    }
    analyze(tree, providedOptions) {
        const options = this.updateDeeply(this.defaultOptions(), providedOptions);
        this.comments = options.comments;
        const scopeManager = new scopeManager_1.ScopeManager(options);
        const referencer = new referencer_1.Referencer(options, scopeManager);
        referencer.visit(tree);
        assert(scopeManager.__currentScope === null, "currentScope should be null.");
        this.scopeManager = scopeManager;
        const pureCommentEndsSet = this.processComments();
        const { moduleScope } = this;
        this.unionFind = new utils_1.UnionFind(moduleScope.variables.length + 1);
        moduleScope.variables.forEach(variable => {
            const index = this.virtualScopes.length;
            let virtualScope;
            if (moduleScope.importManager.idMap.get(variable.name)) {
                virtualScope = new virtualScope_1.VariableVirtualScope(index, virtualScope_1.VScopeContentType.Import, variable);
            }
            else {
                const def = variable.defs[0];
                switch (def.node.type) {
                    case "FunctionDeclaration":
                        virtualScope = new virtualScope_1.VariableVirtualScope(index, virtualScope_1.VScopeContentType.FunctionDeclaration, variable);
                        break;
                    case "ClassDeclaration":
                        virtualScope = new virtualScope_1.VariableVirtualScope(index, virtualScope_1.VScopeContentType.ClassDeclaration, variable);
                        break;
                    case "VariableDeclarator":
                        let isChildrenDependent = true;
                        if (def.node.init) {
                            const { init } = def.node;
                            if (["let", "var", "const"].indexOf(def.kind) < 0) {
                                throw new TypeError("def.kind muse be in ['let', 'var', 'const']");
                            }
                            if (def.kind === "let" || def.kind === "var") {
                                for (let i = 1; i < variable.references.length; i++) {
                                    const ref = variable.references[i];
                                    if (ref.flag === reference_1.Reference.WRITE || ref.flag === reference_1.Reference.RW) {
                                        isChildrenDependent = false;
                                        break;
                                    }
                                }
                            }
                            let scopeType = virtualScope_1.VScopeContentType.Undefined;
                            switch (init.type) {
                                case "ClassExpression":
                                    scopeType = virtualScope_1.VScopeContentType.ClassExpression;
                                    break;
                                case "FunctionExpression":
                                    scopeType = virtualScope_1.VScopeContentType.FunctionExpression;
                                    break;
                                case "ArrowFunctionExpression":
                                    scopeType = virtualScope_1.VScopeContentType.ArrowFunction;
                                    break;
                                case "CallExpression":
                                    if (pureCommentEndsSet.has(init.range[0])) {
                                        scopeType = virtualScope_1.VScopeContentType.PureFunctionCall;
                                    }
                                    else {
                                        scopeType = virtualScope_1.VScopeContentType.NormalFunctionCall;
                                    }
                            }
                            virtualScope = new virtualScope_1.VariableVirtualScope(index, scopeType, variable, isChildrenDependent);
                        }
                        else {
                            virtualScope = new virtualScope_1.VariableVirtualScope(index, virtualScope_1.VScopeContentType.Undefined, variable, false);
                        }
                        break;
                    default:
                        virtualScope = new virtualScope_1.VariableVirtualScope(index, virtualScope_1.VScopeContentType.Undefined, variable, false);
                }
            }
            this.virtualScopeMap.set(variable, virtualScope);
            this.virtualScopes.push(virtualScope);
        });
        const visitedSet = new WeakSet();
        this.handleExportDefaultDeclaration();
        this.virtualScopes.forEach(vs => vs.findAllReferencesToVirtualScope(visitedSet, scopeManager, this.virtualScopeMap));
        const independentScopes = moduleScope.childScopes.filter(item => !visitedSet.has(item));
        this.traverseIndependentScopes(independentScopes);
        this.handleNotExportReferences(moduleScope.references.filter(ref => !ref.isExport));
    }
    processComments() {
        const pureCommentEndsSet = new Set();
        this.comments.forEach(comment => {
            if (comment.type === "Block" && /(@|#)__PURE__/.test(comment.value)) {
                pureCommentEndsSet.add(comment.end);
            }
        });
        return pureCommentEndsSet;
    }
    handleExportDefaultDeclaration() {
        const moduleScope = this.moduleScope;
        const { exportManager } = moduleScope;
        if (exportManager.exportDefaultDeclaration) {
            let vsType;
            switch (exportManager.exportDefaultDeclaration.type) {
                case "FunctionDeclaration":
                    vsType = virtualScope_1.VScopeContentType.FunctionDeclaration;
                    break;
                case "ArrowFunctionExpression":
                    vsType = virtualScope_1.VScopeContentType.ArrowFunction;
                    break;
                case "ClassDeclaration":
                    vsType = virtualScope_1.VScopeContentType.ClassDeclaration;
                    break;
                case "ClassExpression":
                    vsType = virtualScope_1.VScopeContentType.ClassExpression;
                    break;
                case "Identifier":
                    vsType = virtualScope_1.VScopeContentType.Reference;
                    break;
                default:
                    return;
            }
            this.virtualScopes.push(new virtualScope_1.ExportDefaultVirtualScope(this.virtualScopes.length, vsType, exportManager.exportDefaultDeclaration, true));
        }
    }
    generateExportInfo(usedExports) {
        const { exportManager } = this.moduleScope;
        debugger;
        const resultList = [];
        const usedModuleScopeIds = [];
        for (let i = 0; i < usedExports.length; i++) {
            const usedExport = usedExports[i];
            const exportVar = exportManager.exportsMap.get(usedExport);
            if (typeof exportVar === "undefined") {
                continue;
            }
            switch (exportVar.type) {
                case exportManager_1.ExportVariableType.Local:
                    if (exportVar.localName !== null || exportVar.exportName === "default") {
                        usedModuleScopeIds.push(exportVar.localName || exportVar.exportName);
                    }
                    break;
                case exportManager_1.ExportVariableType.External:
                    if (exportVar.moduleType === exportManager_1.ExternalType.Identifier) {
                        resultList.push({
                            sourceName: exportVar.names.sourceName,
                            moduleName: exportVar.moduleName,
                        });
                    }
                    break;
            }
        }
        const unionChildren = (vs) => {
            for (const child of vs.children) {
                this.unionFind.union(vs.id, child.id);
            }
        };
        usedModuleScopeIds.forEach(id => {
            if (id === "default") {
                const defaultVs = this.virtualScopes.filter(vs => vs.type === virtualScope_1.VirtualScopeType.Default);
                defaultVs.forEach(vs => {
                    unionChildren(vs);
                    this.unionFind.union(vs.id, this.rootId);
                });
            }
            else {
                const variable = this.moduleScope.set.get(id);
                const vs = this.virtualScopeMap.get(variable);
                unionChildren(vs);
                this.unionFind.union(vs.id, this.rootId);
            }
        });
        this.virtualScopes.forEach(vs => {
            if (this.unionFind.find(vs.id) !== this.unionFind.find(this.rootId)) {
                return;
            }
            if (vs.type === virtualScope_1.VirtualScopeType.Variable) {
                const varVScope = vs;
                if (vs.contentType === virtualScope_1.VScopeContentType.Import) {
                    const name = varVScope.variable.name;
                    const importInfo = this.moduleScope.importManager.idMap.get(name);
                    if (importInfo.type === importManager_1.ImportType.Namespace) {
                        resultList.push({
                            sourceName: true,
                            moduleName: importInfo.moduleName,
                        });
                    }
                    else {
                        resultList.push({
                            sourceName: importInfo.sourceName,
                            moduleName: importInfo.moduleName,
                        });
                    }
                }
            }
        });
        return this.makeResult(resultList);
    }
    makeResult(resultList) {
        const resultMap = {};
        for (const entity of resultList) {
            const { sourceName, moduleName } = entity;
            if (resultMap[moduleName] === true)
                continue;
            if (sourceName === true) {
                resultMap[moduleName] = true;
            }
            else if (moduleName in resultMap) {
                resultMap[moduleName].add(sourceName);
            }
            else {
                resultMap[moduleName] = new Set([sourceName]);
            }
        }
        for (const key in resultMap) {
            if (resultMap.hasOwnProperty(key)) {
                const value = resultMap[key];
                if (value !== true) {
                    resultMap[key] = [...value].sort();
                }
            }
        }
        return resultMap;
    }
    traverseIndependentScopes(scopes) {
        for (const scope of scopes) {
            const traverser = new childScopesTraverser_1.ChildScopesTraverser(scope);
            traverser.refsToModule.forEach(ref => {
                const variable = this.moduleScope.set.get(ref);
                const vs = this.virtualScopeMap.get(variable);
                this.initVirtualScopes.push(vs);
            });
        }
    }
    updateDeeply(target, override) {
        function isHashObject(value) {
            return (typeof value === "object" &&
                value instanceof Object &&
                !(value instanceof Array) &&
                !(value instanceof RegExp));
        }
        for (const key in override) {
            if (override.hasOwnProperty(key)) {
                const val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        this.updateDeeply(target[key], val);
                    }
                    else {
                        target[key] = this.updateDeeply({}, val);
                    }
                }
                else {
                    target[key] = val;
                }
            }
        }
        return target;
    }
    get moduleScope() {
        return this.scopeManager.scopes[1];
    }
}
exports.ModuleAnalyser = ModuleAnalyser;
//# sourceMappingURL=moduleAnalyser.js.map