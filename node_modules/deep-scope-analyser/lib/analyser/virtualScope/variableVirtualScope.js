"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const estraverse = require("estraverse");
class VariableVirtualScope {
    constructor(id, contentType, variable, isChildrenDependent = true) {
        this.id = id;
        this.contentType = contentType;
        this.variable = variable;
        this.isChildrenDependent = isChildrenDependent;
        this.children = [];
        if (contentType === _1.VScopeContentType.PureFunctionCall) {
            const { declarator } = this;
            this.pureRange = [declarator.start, declarator.end];
        }
    }
    get type() {
        return _1.VirtualScopeType.Variable;
    }
    get declarator() {
        const def = this.variable.defs[0];
        const node = def.node;
        if (typeof node === "undefined") {
            throw new TypeError("node.init is undefined");
        }
        return node;
    }
    get isImport() {
        return this.contentType === _1.VScopeContentType.Import;
    }
    findAllReferencesToVirtualScope(visitedSet, scopeManager, virtualScopeMap) {
        if (!this.isChildrenDependent)
            return;
        switch (this.contentType) {
            case _1.VScopeContentType.ClassDeclaration:
            case _1.VScopeContentType.FunctionDeclaration:
                this.traverseDeclarationScope(visitedSet, scopeManager, virtualScopeMap);
                break;
            case _1.VScopeContentType.ArrowFunction:
            case _1.VScopeContentType.FunctionExpression:
            case _1.VScopeContentType.ClassExpression:
                this.traverseExpressionScope(visitedSet, scopeManager, virtualScopeMap);
                break;
            case _1.VScopeContentType.PureFunctionCall:
                this.traversePureDeclarator(visitedSet, this.declarator, scopeManager, virtualScopeMap);
                break;
            case _1.VScopeContentType.NormalFunctionCall:
                break;
            case _1.VScopeContentType.Undefined:
                break;
        }
    }
    getModuleScope(scopeManager) {
        return scopeManager.scopes[1];
    }
    traverseDeclarationScope(visitedSet, scopeManager, virtualScopeMap) {
        const def = this.variable.defs[0];
        const scopes = scopeManager.__nodeToScope.get(def.node);
        const moduleScope = this.getModuleScope(scopeManager);
        this.traverseScopes(scopes, moduleScope, visitedSet, virtualScopeMap);
    }
    traverseExpressionScope(visitedSet, scopeManager, virtualScopeMap) {
        const def = this.variable.defs[0];
        const node = def.node;
        const { init } = node;
        const scopes = scopeManager.__nodeToScope.get(init);
        const moduleScope = this.getModuleScope(scopeManager);
        this.traverseScopes(scopes, moduleScope, visitedSet, virtualScopeMap);
    }
    traverseScopes(scopes, moduleScope, visitedSet, virtualScopeMap) {
        scopes.forEach(scope => {
            visitedSet.add(scope);
            const traverse = (scope) => {
                scope.references.forEach(ref => {
                    if (ref.resolved &&
                        ref.resolved.scope.type === "module") {
                        const idName = ref.identifier.name;
                        this.addToVs(idName, moduleScope, virtualScopeMap);
                    }
                });
                scope.childScopes.forEach(traverse);
            };
            traverse(scope);
        });
    }
    traversePureDeclarator(visitedSet, validatorDeclarator, scopeManager, virtualScopeMap) {
        const moduleScope = this.getModuleScope(scopeManager);
        const nodeContains = (node1, node2) => {
            return node2.start >= node1.start && node2.end <= node1.end;
        };
        moduleScope.childScopes.forEach(scope => {
            const block = scope.block;
            if (nodeContains(validatorDeclarator, block)) {
                visitedSet.add(scope);
            }
        });
        estraverse.traverse(validatorDeclarator, {
            enter: (node) => {
                if (node.type === "Identifier") {
                    const idName = node.name;
                    this.addToVs(idName, moduleScope, virtualScopeMap);
                }
            },
        });
    }
    addToVs(idName, moduleScope, virtualScopeMap) {
        const refVar = moduleScope.set.get(idName);
        if (typeof refVar !== "undefined") {
            const virtualScope = virtualScopeMap.get(refVar);
            this.children.push(virtualScope);
        }
    }
}
exports.VariableVirtualScope = VariableVirtualScope;
//# sourceMappingURL=variableVirtualScope.js.map