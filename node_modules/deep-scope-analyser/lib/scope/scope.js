"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const variable_1 = require("../variable");
const reference_1 = require("../reference");
const estraverse_1 = require("estraverse");
function isStrictScope(scope, block, isMethodDefinition, useDirective) {
    let body;
    if (scope.upper && scope.upper.isStrict) {
        return true;
    }
    if (block.type === estraverse_1.Syntax.ArrowFunctionExpression) {
        return true;
    }
    if (isMethodDefinition) {
        return true;
    }
    if (scope.type === "class" || scope.type === "module") {
        return true;
    }
    if (scope.type === "block" || scope.type === "switch") {
        return false;
    }
    if (scope.type === "function") {
        if (block.type === estraverse_1.Syntax.Program) {
            body = block;
        }
        else {
            body = block.body;
        }
        if (!body) {
            return false;
        }
    }
    else if (scope.type === "global") {
        body = block;
    }
    else {
        return false;
    }
    if (useDirective) {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
            const stmt = body.body[i];
            if (stmt.type !== estraverse_1.Syntax.DirectiveStatement) {
                break;
            }
            if (stmt.raw === '"use strict"' ||
                stmt.raw === "'use strict'") {
                return true;
            }
        }
    }
    else {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
            const stmt = body.body[i];
            if (stmt.type !== estraverse_1.Syntax.ExpressionStatement) {
                break;
            }
            const expr = stmt.expression;
            if (expr.type !== estraverse_1.Syntax.Literal ||
                typeof expr.value !== "string") {
                break;
            }
            if (expr.raw !== null && expr.raw !== undefined) {
                if (expr.raw === '"use strict"' ||
                    expr.raw === "'use strict'") {
                    return true;
                }
            }
            else {
                if (expr.value === "use strict") {
                    return true;
                }
            }
        }
    }
    return false;
}
function registerScope(scopeManager, scope) {
    scopeManager.scopes.push(scope);
    const scopes = scopeManager.__nodeToScope.get(scope.block);
    if (scopes) {
        scopes.push(scope);
    }
    else {
        scopeManager.__nodeToScope.set(scope.block, [scope]);
    }
}
function shouldBeStatically(def) {
    return (def.type === variable_1.VariableType.ClassName ||
        (def.type === variable_1.VariableType.Variable &&
            def.parent.kind !== "var"));
}
class Scope {
    constructor(scopeManager, type, upper = null, block, isMethodDefinition) {
        this.type = type;
        this.upper = upper;
        this.block = block;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;
        this.__left = [];
        this.set = new Map();
        this.taints = new Map();
        this.through = [];
        this.variables = [];
        this.references = [];
        this.childScopes = [];
        this.dynamic =
            this.type === "global" || this.type === "with";
        this.variableScope =
            this.type === "global" ||
                this.type === "function" ||
                this.type === "module"
                ? this
                : this.upper.variableScope;
        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
        if (this.upper) {
            this.upper.childScopes.push(this);
        }
        this.__declaredVariables = scopeManager.__declaredVariables;
        registerScope(scopeManager, this);
    }
    __shouldStaticallyClose(scopeManager) {
        return !this.dynamic || scopeManager.__isOptimistic();
    }
    __shouldStaticallyCloseForGlobal(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
            return false;
        }
        const variable = this.set.get(name);
        const defs = variable.defs;
        return defs.length > 0 && defs.every(shouldBeStatically);
    }
    __staticCloseRef(ref) {
        if (!this.__resolve(ref)) {
            this.__delegateToUpperScope(ref);
        }
    }
    __dynamicCloseRef(ref) {
        let current = this;
        do {
            current.through.push(ref);
            current = current.upper;
        } while (current);
    }
    __globalCloseRef(ref) {
        if (this.__shouldStaticallyCloseForGlobal(ref)) {
            this.__staticCloseRef(ref);
        }
        else {
            this.__dynamicCloseRef(ref);
        }
    }
    __close(scopeManager) {
        let closeRef;
        if (this.__shouldStaticallyClose(scopeManager)) {
            closeRef = this.__staticCloseRef;
        }
        else if (this.type !== "global") {
            closeRef = this.__dynamicCloseRef;
        }
        else {
            closeRef = this.__globalCloseRef;
        }
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
            const ref = this.__left[i];
            closeRef.call(this, ref);
        }
        this.__left = null;
        return this.upper;
    }
    __isValidResolution(ref, variable) {
        return true;
    }
    __resolve(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
            return false;
        }
        const variable = this.set.get(name);
        if (!this.__isValidResolution(ref, variable)) {
            return false;
        }
        variable.references.push(ref);
        variable.stack =
            variable.stack &&
                ref.from.variableScope === this.variableScope;
        if (ref.tainted) {
            variable.tainted = true;
            this.taints.set(variable.name, true);
        }
        ref.resolved = variable;
        return true;
    }
    __delegateToUpperScope(ref) {
        if (this.upper) {
            this.upper.__left.push(ref);
        }
        this.through.push(ref);
    }
    __addDeclaredVariablesOfNode(variable, node) {
        if (node === null || node === undefined) {
            return;
        }
        let variables = this.__declaredVariables.get(node);
        if (variables === null || variables === undefined) {
            variables = [];
            this.__declaredVariables.set(node, variables);
        }
        if (variables.indexOf(variable) === -1) {
            variables.push(variable);
        }
    }
    __defineGeneric(name, set, variables, node, def) {
        let variable;
        variable = set.get(name);
        if (!variable) {
            variable = new variable_1.Variable(name, this);
            set.set(name, variable);
            variables.push(variable);
        }
        if (def) {
            variable.defs.push(def);
            if (def.type !== variable_1.VariableType.TDZ) {
                this.__addDeclaredVariablesOfNode(variable, def.node);
                this.__addDeclaredVariablesOfNode(variable, def.parent);
            }
        }
        if (node) {
            variable.identifiers.push(node);
        }
        return variable;
    }
    __define(node, def) {
        if (node && node.type === estraverse_1.Syntax.Identifier) {
            return this.__defineGeneric(node.name, this.set, this.variables, node, def);
        }
        return null;
    }
    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init, isExportingFromLocal = false) {
        if (!node || node.type !== estraverse_1.Syntax.Identifier) {
            return;
        }
        if (node.name === "super") {
            return;
        }
        const ref = new reference_1.Reference(node, this, isExportingFromLocal
            ? reference_1.Reference.EXPORT
            : assign || reference_1.Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
        this.references.push(ref);
        this.__left.push(ref);
        return ref;
    }
    __detectEval() {
        let current = this;
        this.directCallToEvalScope = true;
        do {
            current.dynamic = true;
            current = current.upper;
        } while (current);
    }
    __detectThis() {
        this.thisFound = true;
    }
    __isClosed() {
        return this.__left === null;
    }
    resolve(ident) {
        let ref, i, iz;
        assert(this.__isClosed(), "Scope should be closed.");
        assert(ident.type === estraverse_1.Syntax.Identifier, "Target should be identifier.");
        for (i = 0, iz = this.references.length; i < iz; ++i) {
            ref = this.references[i];
            if (ref.identifier === ident) {
                return ref;
            }
        }
        return null;
    }
    isStatic() {
        return !this.dynamic;
    }
    isArgumentsMaterialized() {
        return true;
    }
    isThisMaterialized() {
        return true;
    }
    isUsedName(name) {
        if (this.set.has(name)) {
            return true;
        }
        for (let i = 0, iz = this.through.length; i < iz; ++i) {
            if (this.through[i].identifier.name === name) {
                return true;
            }
        }
        return false;
    }
}
exports.Scope = Scope;
//# sourceMappingURL=scope.js.map