"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const estraverse_1 = require("estraverse");
const esrecurse = require("esrecurse");
const reference_1 = require("./reference");
const variable_1 = require("./variable");
const patternVisitor_1 = require("./patternVisitor");
const definition_1 = require("./definition");
const assert = require("assert");
const importManager_1 = require("./importManager");
const exportManager_1 = require("./exportManager");
function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
    const visitor = new patternVisitor_1.PatternVisitor(options, rootPattern, callback);
    visitor.visit(rootPattern);
    if (referencer !== null && referencer !== undefined) {
        visitor.rightHandNodes.forEach(referencer.visit, referencer);
    }
}
class Importer extends esrecurse.Visitor {
    constructor(declaration, referencer) {
        super(undefined, referencer.options);
        this.declaration = declaration;
        this.referencer = referencer;
    }
    get moduleScope() {
        return this.referencer.currentScope;
    }
    visitImport(id, specifier) {
        this.referencer.visitPattern(id, undefined, pattern => {
            this.referencer.currentScope.__define(pattern, new definition_1.Definition(variable_1.VariableType.ImportBinding, pattern, specifier, this.declaration));
        });
    }
    ImportNamespaceSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
        const importId = new importManager_1.ImportIdentifierInfo(local.name, local.name, this.declaration.source.value, importManager_1.ImportType.Namespace);
        this.moduleScope.importManager.addImportId(importId);
    }
    ImportDefaultSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
        const importId = new importManager_1.ImportIdentifierInfo(local.name, "default", this.declaration.source.value, importManager_1.ImportType.Default);
        this.moduleScope.importManager.addImportId(importId);
    }
    ImportSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
        const importId = new importManager_1.ImportIdentifierInfo(local.name, node.imported.name, this.declaration.source.value, importManager_1.ImportType.Identifier);
        this.moduleScope.importManager.addImportId(importId);
    }
}
class Referencer extends esrecurse.Visitor {
    constructor(options, scopeManager) {
        super(undefined, options);
        this.options = options;
        this.scopeManager = scopeManager;
        this.parent = null;
        this.isInnerMethodDefinition = false;
        this.exportingSource = null;
        this.isExportingFromLocal = false;
    }
    get currentScope() {
        return this.scopeManager.__currentScope;
    }
    close(node) {
        while (this.currentScope &&
            node === this.currentScope.block) {
            this.scopeManager.__currentScope = this.currentScope.__close(this.scopeManager);
        }
    }
    pushInnerMethodDefinition(isInnerMethodDefinition) {
        const previous = this.isInnerMethodDefinition;
        this.isInnerMethodDefinition = isInnerMethodDefinition;
        return previous;
    }
    popInnerMethodDefinition(isInnerMethodDefinition) {
        this.isInnerMethodDefinition = isInnerMethodDefinition;
    }
    materializeTDZScope(node, iterationNode) {
        this.scopeManager.__nestTDZScope(node);
        this.visitVariableDeclaration(this.currentScope, variable_1.VariableType.TDZ, iterationNode.left, 0, true);
    }
    materializeIterationScope(node) {
        const letOrConstDecl = node.left;
        this.scopeManager.__nestForScope(node);
        this.visitVariableDeclaration(this.currentScope, variable_1.VariableType.Variable, letOrConstDecl, 0);
        this.visitPattern(letOrConstDecl.declarations[0].id, undefined, pattern => {
            this.currentScope.__referencing(pattern, reference_1.Reference.WRITE, node.right, undefined, true, true);
        });
    }
    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
        const scope = this.currentScope;
        assignments.forEach(assignment => {
            scope.__referencing(pattern, reference_1.Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
        });
    }
    visitPattern(node, options = { processRightHandNodes: false }, callback) {
        traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
    }
    visitFunction(node) {
        let i, iz;
        if (node.type === estraverse_1.Syntax.FunctionDeclaration) {
            this.currentScope.__define(node.id, new definition_1.Definition(variable_1.VariableType.FunctionName, node.id, node));
        }
        if (node.type === estraverse_1.Syntax.FunctionExpression && node.id) {
            this.scopeManager.__nestFunctionExpressionNameScope(node);
        }
        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
        const that = this;
        function visitPatternCallback(pattern, info) {
            that.currentScope.__define(pattern, new definition_1.ParameterDefinition(pattern, node, i, info.rest));
            that.referencingDefaultValue(pattern, info.assignments, undefined, true);
        }
        for (i = 0, iz = node.params.length; i < iz; ++i) {
            this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);
        }
        if (node.body) {
            if (node.body.type === estraverse_1.Syntax.BlockStatement) {
                this.visitChildren(node.body);
            }
            else {
                this.visit(node.body);
            }
        }
        this.close(node);
    }
    visitClass(node) {
        if (node.type === estraverse_1.Syntax.ClassDeclaration) {
            this.currentScope.__define(node.id, new definition_1.Definition(variable_1.VariableType.ClassName, node.id, node));
        }
        this.visit(node.superClass);
        this.scopeManager.__nestClassScope(node);
        if (node.id) {
            this.currentScope.__define(node.id, new definition_1.Definition(variable_1.VariableType.ClassName, node.id, node));
        }
        this.visit(node.body);
        this.close(node);
    }
    visitProperty(node) {
        let previous;
        if (node.computed) {
            this.visit(node.key);
        }
        const isMethodDefinition = node.type === estraverse_1.Syntax.MethodDefinition;
        if (isMethodDefinition) {
            previous = this.pushInnerMethodDefinition(true);
        }
        this.visit(node.value);
        if (isMethodDefinition) {
            this.popInnerMethodDefinition(previous);
        }
    }
    visitForIn(node) {
        if (node.left.type === estraverse_1.Syntax.VariableDeclaration &&
            node.left.kind !== "var") {
            this.materializeTDZScope(node.right, node);
            this.visit(node.right);
            this.close(node.right);
            this.materializeIterationScope(node);
            this.visit(node.body);
            this.close(node);
        }
        else {
            if (node.left.type === estraverse_1.Syntax.VariableDeclaration) {
                this.visit(node.left);
                this.visitPattern(node.left.declarations[0].id, undefined, pattern => {
                    this.currentScope.__referencing(pattern, reference_1.Reference.WRITE, node.right, undefined, true, true);
                });
            }
            else {
                this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
                    let maybeImplicitGlobal;
                    if (!this.currentScope.isStrict) {
                        maybeImplicitGlobal = {
                            pattern,
                            node,
                        };
                    }
                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                    this.currentScope.__referencing(pattern, reference_1.Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
                });
            }
            this.visit(node.right);
            this.visit(node.body);
        }
    }
    visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
        const decl = node.declarations[index];
        const init = decl.init;
        this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, (pattern, info) => {
            variableTargetScope.__define(pattern, new definition_1.Definition(type, pattern, decl, node, index, node.kind));
            if (!fromTDZ) {
                this.referencingDefaultValue(pattern, info.assignments, undefined, true);
            }
            if (init) {
                this.currentScope.__referencing(pattern, reference_1.Reference.WRITE, init, undefined, !info.topLevel, true);
            }
        });
    }
    AssignmentExpression(node) {
        if (patternVisitor_1.PatternVisitor.isPattern(node.left)) {
            if (node.operator === "=") {
                this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
                    let maybeImplicitGlobal;
                    if (!this.currentScope.isStrict) {
                        maybeImplicitGlobal = {
                            pattern,
                            node,
                        };
                    }
                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                    this.currentScope.__referencing(pattern, reference_1.Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
                });
            }
            else {
                this.currentScope.__referencing(node.left, reference_1.Reference.RW, node.right);
            }
        }
        else {
            this.visit(node.left);
        }
        this.visit(node.right);
    }
    CatchClause(node) {
        this.scopeManager.__nestCatchScope(node);
        this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {
            this.currentScope.__define(pattern, new definition_1.Definition(variable_1.VariableType.CatchClause, node.param, node));
            this.referencingDefaultValue(pattern, info.assignments, undefined, true);
        });
        this.visit(node.body);
        this.close(node);
    }
    Program(node) {
        this.scopeManager.__nestGlobalScope(node);
        if (this.scopeManager.__isNodejsScope()) {
            this.currentScope.isStrict = false;
            this.scopeManager.__nestFunctionScope(node, false);
        }
        if (this.scopeManager.__isES6() &&
            this.scopeManager.isModule()) {
            this.scopeManager.__nestModuleScope(node);
        }
        if (this.scopeManager.isStrictModeSupported() &&
            this.scopeManager.isImpliedStrict()) {
            this.currentScope.isStrict = true;
        }
        this.visitChildren(node);
        this.close(node);
    }
    Identifier(node) {
        this.currentScope.__referencing(node, undefined, undefined, undefined, undefined, undefined, this.isExportingFromLocal);
    }
    UpdateExpression(node) {
        if (patternVisitor_1.PatternVisitor.isPattern(node.argument)) {
            this.currentScope.__referencing(node.argument, reference_1.Reference.RW);
        }
        else {
            this.visitChildren(node);
        }
    }
    MemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
            this.visit(node.property);
        }
    }
    Property(node) {
        this.visitProperty(node);
    }
    MethodDefinition(node) {
        this.visitProperty(node);
    }
    BreakStatement() { }
    ContinueStatement() { }
    LabeledStatement(node) {
        this.visit(node.body);
    }
    ForStatement(node) {
        if (node.init &&
            node.init.type === estraverse_1.Syntax.VariableDeclaration &&
            node.init.kind !== "var") {
            this.scopeManager.__nestForScope(node);
        }
        this.visitChildren(node);
        this.close(node);
    }
    ClassExpression(node) {
        this.visitClass(node);
    }
    ClassDeclaration(node) {
        this.visitClass(node);
    }
    CallExpression(node) {
        if (!this.scopeManager.__ignoreEval() &&
            node.callee.type === estraverse_1.Syntax.Identifier &&
            node.callee.name === "eval") {
            this.currentScope.variableScope.__detectEval();
        }
        this.visitChildren(node);
    }
    BlockStatement(node) {
        if (this.scopeManager.__isES6()) {
            this.scopeManager.__nestBlockScope(node);
        }
        this.visitChildren(node);
        this.close(node);
    }
    ThisExpression() {
        this.currentScope.variableScope.__detectThis();
    }
    WithStatement(node) {
        this.visit(node.object);
        this.scopeManager.__nestWithScope(node);
        this.visit(node.body);
        this.close(node);
    }
    VariableDeclaration(node) {
        const variableTargetScope = node.kind === "var"
            ? this.currentScope.variableScope
            : this.currentScope;
        for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
            const decl = node.declarations[i];
            this.visitVariableDeclaration(variableTargetScope, variable_1.VariableType.Variable, node, i);
            if (decl.init) {
                this.visit(decl.init);
            }
        }
    }
    SwitchStatement(node) {
        this.visit(node.discriminant);
        if (this.scopeManager.__isES6()) {
            this.scopeManager.__nestSwitchScope(node);
        }
        for (let i = 0, iz = node.cases.length; i < iz; ++i) {
            this.visit(node.cases[i]);
        }
        this.close(node);
    }
    FunctionDeclaration(node) {
        this.visitFunction(node);
    }
    FunctionExpression(node) {
        this.visitFunction(node);
    }
    ForOfStatement(node) {
        this.visitForIn(node);
    }
    ForInStatement(node) {
        this.visitForIn(node);
    }
    ArrowFunctionExpression(node) {
        this.visitFunction(node);
    }
    ImportDeclaration(node) {
        assert(this.scopeManager.__isES6() &&
            this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
        const importer = new Importer(node, this);
        importer.visit(node);
    }
    visitExportDeclaration(node) {
        if (node.source) {
            this.exportingSource = node.source.value;
        }
        else {
            this.exportingSource = null;
        }
        if (node.declaration) {
            this.visit(node.declaration);
            return;
        }
        this.visitChildren(node);
    }
    ExportNamedDeclaration(node) {
        const moduleScope = this.currentScope;
        const previous = moduleScope.isExportingNamedDeclaration;
        moduleScope.isExportingNamedDeclaration = true;
        this.visitExportDeclaration(node);
        moduleScope.isExportingNamedDeclaration = previous;
    }
    ExportDefaultDeclaration(node) {
        const currentScope = this.currentScope;
        if (currentScope.type !== "module") {
            throw new Error("use export in a non module scope");
        }
        let localExportVar;
        if (node.declaration.type === "Identifier") {
            localExportVar = {
                type: exportManager_1.ExportVariableType.Local,
                exportName: "default",
                localName: node.declaration.name,
                node: node.declaration,
            };
            this.isExportingFromLocal = true;
            this.visit(node.declaration);
            this.isExportingFromLocal = false;
        }
        else {
            localExportVar = {
                type: exportManager_1.ExportVariableType.Local,
                exportName: "default",
                localName: null,
                node: node.declaration,
            };
            this.visit(node.declaration);
        }
        currentScope.exportManager.addLocalExportVariable(localExportVar);
    }
    ExportAllDeclaration(node) {
        const currentScope = this.currentScope;
        currentScope.exportManager.addExternalVariable({
            type: exportManager_1.ExportVariableType.External,
            moduleName: node.source.value,
            moduleType: exportManager_1.ExternalType.All,
        });
    }
    ExportSpecifier(node) {
        const local = node.local;
        const currentScope = this.currentScope;
        if (this.exportingSource) {
            currentScope.exportManager.addExternalVariable({
                type: exportManager_1.ExportVariableType.External,
                moduleName: this.exportingSource,
                moduleType: exportManager_1.ExternalType.Identifier,
                names: {
                    exportName: node.exported.name,
                    sourceName: node.local.name,
                },
            });
        }
        else {
            this.isExportingFromLocal = true;
            this.visit(local);
            currentScope.exportManager.addLocalExportVariable({
                type: exportManager_1.ExportVariableType.Local,
                exportName: node.exported.name,
                localName: node.local.name,
                node: node.local,
            });
            this.isExportingFromLocal = false;
        }
    }
    MetaProperty() {
    }
}
exports.Referencer = Referencer;
//# sourceMappingURL=referencer.js.map