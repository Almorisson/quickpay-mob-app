"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_1 = require("./scope");
const assert = require("assert");
class ScopeManager {
    constructor(__options) {
        this.__options = __options;
        this.globalScope = null;
        this.__currentScope = null;
        this.scopes = [];
        this.__nodeToScope = new WeakMap();
        this.__declaredVariables = new WeakMap();
    }
    __useDirective() {
        return this.__options.directive;
    }
    __isOptimistic() {
        return this.__options.optimistic;
    }
    __ignoreEval() {
        return this.__options.ignoreEval;
    }
    __isNodejsScope() {
        return this.__options.nodejsScope;
    }
    isModule() {
        return this.__options.sourceType === "module";
    }
    isImpliedStrict() {
        return this.__options.impliedStrict;
    }
    isStrictModeSupported() {
        return this.__options.ecmaVersion >= 5;
    }
    __get(node) {
        return this.__nodeToScope.get(node);
    }
    getDeclaredVariables(node) {
        return this.__declaredVariables.get(node) || [];
    }
    acquire(node, inner) {
        function predicate(testScope) {
            if (testScope.type === "function" &&
                testScope.functionExpressionScope) {
                return false;
            }
            if (testScope.type === "TDZ") {
                return false;
            }
            return true;
        }
        const scopes = this.__get(node);
        if (!scopes || scopes.length === 0) {
            return null;
        }
        if (scopes.length === 1) {
            return scopes[0];
        }
        if (inner) {
            for (let i = scopes.length - 1; i >= 0; --i) {
                const scope = scopes[i];
                if (predicate(scope)) {
                    return scope;
                }
            }
        }
        else {
            for (let i = 0, iz = scopes.length; i < iz; ++i) {
                const scope = scopes[i];
                if (predicate(scope)) {
                    return scope;
                }
            }
        }
        return null;
    }
    acquireAll(node) {
        return this.__get(node);
    }
    release(node, inner) {
        const scopes = this.__get(node);
        if (scopes && scopes.length) {
            const scope = scopes[0].upper;
            if (!scope) {
                return null;
            }
            return this.acquire(scope.block, inner);
        }
        return null;
    }
    attach() { }
    detach() { }
    __nestScope(scope) {
        if (scope instanceof scope_1.GlobalScope) {
            assert(this.__currentScope === null);
            this.globalScope = scope;
        }
        this.__currentScope = scope;
        return scope;
    }
    __nestGlobalScope(node) {
        return this.__nestScope(new scope_1.GlobalScope(this, node));
    }
    __nestBlockScope(node) {
        return this.__nestScope(new scope_1.BlockScope(this, this.__currentScope, node));
    }
    __nestFunctionScope(node, isMethodDefinition) {
        return this.__nestScope(new scope_1.FunctionScope(this, this.__currentScope, node, isMethodDefinition));
    }
    __nestForScope(node) {
        return this.__nestScope(new scope_1.ForScope(this, this.__currentScope, node));
    }
    __nestCatchScope(node) {
        return this.__nestScope(new scope_1.CatchScope(this, this.__currentScope, node));
    }
    __nestWithScope(node) {
        return this.__nestScope(new scope_1.WithScope(this, this.__currentScope, node));
    }
    __nestClassScope(node) {
        return this.__nestScope(new scope_1.ClassScope(this, this.__currentScope, node));
    }
    __nestSwitchScope(node) {
        return this.__nestScope(new scope_1.SwitchScope(this, this.__currentScope, node));
    }
    __nestModuleScope(node) {
        return this.__nestScope(new scope_1.ModuleScope(this, this.__currentScope, node));
    }
    __nestTDZScope(node) {
        return this.__nestScope(new scope_1.TDZScope(this, this.__currentScope, node));
    }
    __nestFunctionExpressionNameScope(node) {
        return this.__nestScope(new scope_1.FunctionExpressionNameScope(this, this.__currentScope, node));
    }
    __isES6() {
        return this.__options.ecmaVersion >= 6;
    }
}
exports.ScopeManager = ScopeManager;
//# sourceMappingURL=scopeManager.js.map